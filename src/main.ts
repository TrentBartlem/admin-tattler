import { Devvit } from '@devvit/public-api';
import { settings, getValidatedSettings } from './settings.js';
import { cacheComment, cacheModerators, cachePost, getCachedComment, getCachedModerators, getCachedPost } from './cache.js';

Devvit.configure({
  redditAPI: true,
  http: true,
  redis: true
});

Devvit.addSettings(settings);

Devvit.addTrigger({
  event: 'ModAction',
  onEvent: async (event, context) => {

    const action = event.action;
    if (!action) {
      throw new Error('Missing `action` from ModActionTrigger event');
    }

    const moderator = event.moderator;
    if (!moderator || !moderator.name) {
      throw new Error('Missing `moderator` from ModActionTrigger event');
    }
    const moderatorName = moderator.name;

    const subreddit = event.subreddit;
    if (!subreddit || !subreddit.name) {
      throw new Error('Missing `subreddit` from ModActionTrigger event');
    }
    const subredditName = subreddit.name;

    const settings = await getValidatedSettings(context);

    // Update cached modlist on modlist change
    if (
      action == "acceptmoderatorinvite" || action == "addmoderator" ||
      action == "removemoderator" || action == "reordermoderators"
    ) {
      console.log(`Updating cached modlist on ${action} by ${moderatorName}`);
      await cacheModerators(context);
    }

    // Check if acting moderator is NOT in modlist
    const moderators = await getCachedModerators(context);
    if (
      !moderators.includes(moderatorName) && 
      moderatorName != "AutoModerator" && moderatorName != "reddit"
    ) {

      // Ignore user removing themselves as moderator
      if (action == "removemoderator" && moderatorName == event.targetUser!.name) {
        console.log(`Ignored ${action} by ${moderatorName}`);
        return;
      }

      console.log(`Detected ${action} by ${moderatorName}`);

      let permalink = "";
      let user = "";
      let url = "";
      let title = "";
      let body = "";
      let usedCachedTitle = false;
      let usedCachedBody = false;

      // Posts
      const targetPost = event.targetPost;
      if (targetPost && targetPost.id) {
        if (targetPost.permalink) {
          permalink = `https://www.reddit.com${targetPost.permalink}`;
        }
        if (targetPost.url && !targetPost.isSelf) {
          url = targetPost.url;
        }
        if (targetPost.selftext) {
          body = targetPost.selftext;
        }
        if (targetPost.title) {
          title = targetPost.title;
          if (title == "[ Removed by Reddit ]") {
            const cachedPost = await getCachedPost(targetPost.id, context);
            if (cachedPost) {
              if (cachedPost.title) {
                title = cachedPost.title;
                usedCachedTitle = true;
              }
              if (cachedPost.body) {
                body = cachedPost.body;
                usedCachedBody = true;
              }
            }
          }
        }
      }

      // Comments
      const targetComment = event.targetComment;
      if (targetComment && targetComment.id) {
        if (targetComment.permalink) {
          permalink = `https://www.reddit.com${targetComment.permalink}`;
        }
        if (targetComment.body) {
          body = targetComment.body;
          if (body == "[ Removed by Reddit ]") {
            const cachedComment = await getCachedComment(targetComment.id, context);
            if (cachedComment) {
              body = cachedComment;
              usedCachedBody = true;
            }
          }
        }
      }

      // Target User
      const targetUser = event.targetUser;
      if (targetUser && targetUser.id) {
        user = targetUser.name;
      }

      let isUser = false;
      let modlogLinkDesc = "View Admin Modlog";
      let modlogLink = `https://www.reddit.com/r/${subredditName}/about/log?mod=a&moderatorNames=a`;
      if (moderatorName != "Anti-Evil Operations" && moderatorName != "Reddit Legal") {
        isUser = true;
        modlogLinkDesc = "View User Modlog";
        modlogLink = `https://www.reddit.com/r/${subredditName}/about/log?mod=${moderatorName}&moderatorNames=${moderatorName}`;
      }

      // Send Modmail
      if (settings.sendModmail) {
        const msg = `**${ isUser ? "u/" : "" }${moderatorName}** has performed an action in r/${subredditName}:\n\n` +
                    `* **Action:** \`${action}\`` +
                    (permalink ? `\n\n* **Permalink:** ${permalink}` : "") +
                    (user ? `\n\n* **Target User:** u/${user}` : "") +
                    (url ? `\n\n* **URL:** ${url}` : "") +
                    (title ? `\n\n* **Title${ usedCachedTitle ? " (Cached)" : "" }:** ${title}` : "") +
                    (body ? `\n\n* **Body${ usedCachedBody ? " (Cached)" : "" }:** ${body}` : "") +
                    `\n\n[**${modlogLinkDesc}**](${modlogLink})\n\n` +
                    `^(Notification generated by )[^Admin ^Tattler](https://developers.reddit.com/apps/admin-tattler)` +
                    `^(. Configure settings )[^here](https://developers.reddit.com/r/${subredditName}/apps/admin-tattler)^(.)`;
        await context.reddit.modMail.createConversation({
          to: "admin-tattler",
          subject: "Admin Action Detected",
          body: msg,
          subredditName: subredditName,
        })
        .then(() => console.log(`Sent modmail about ${action} by ${moderatorName}`))
        .catch((e) => console.error(`Error sending modmail about ${action} by ${moderatorName}`, e));
      }

      // Send to Slack
      if (settings.webhookURL && settings.webhookURL.startsWith("https://hooks.slack.com/")) {
        const slackPayload = {
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `*${ isUser ? "u/" : "" }${moderatorName}* has performed an action in r/${subredditName}:`
              }
            },
            {
              type: "context",
              elements: [
                {
                  type: "mrkdwn",
                  text: `*Action:* \`${action}\`` +
                        (permalink ? `\n*Permalink:* ${permalink}` : "") +
                        (user ? `\n*Target User:* <https://www.reddit.com/user/${user}|u/${user}>` : "") +
                        (url ? `\n*URL:* ${url}` : "") +
                        (title ? `\n*Title${ usedCachedTitle ? " (Cached)" : "" }:* ${title}` : "") +
                        (body ? `\n*Body${ usedCachedBody ? " (Cached)" : "" }:* ${body}` : "")
                }
              ]
            },
            {
              type: "actions",
              elements: [
                {
                  type: "button",
                  text: {
                    type: "plain_text",
                    text: modlogLinkDesc
                  },
                  url: modlogLink
                }
              ]
            },
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `\`\`\`${JSON.stringify(event)}\`\`\``
              }
            }
          ]
        };
        await fetch(settings.webhookURL, {
          method: 'POST',
          body: JSON.stringify(slackPayload),
        })
          .then(() => console.log(`Sent Slack message about ${action} by ${moderatorName}`))
          .catch((e) => console.error(`Error sending Slack message about ${action} by ${moderatorName}`, e));
      }

      // Send to Discord
      if (settings.webhookURL && settings.webhookURL.startsWith("https://discord.com/api/webhooks/")) {
        const discordPayload = {
          username: "Admin Tattler",
          content: `**${ isUser ? "u/" : "" }${moderatorName}** has performed an action in r/${subredditName}`,
          embeds: [
            {
              color: 16729344, // #FF4500 (OrangeRed)
              fields: [
                {
                  name: "Action",
                  value: `\`${action}\``
                }
              ]
            }
          ]
        };

        if (permalink) {
          discordPayload.embeds[0].fields.push({
            name: "Permalink",
            value: permalink
          });
        }

        if (user) {
          discordPayload.embeds[0].fields.push({
            name: "Target User",
            value: `[u/${user}](https://www.reddit.com/user/${user})`
          });
        }

        if (url) {
          discordPayload.embeds[0].fields.push({
            name: "URL",
            value: url
          });
        }

        if (title) {
          discordPayload.embeds[0].fields.push({
            name: (usedCachedTitle ? "Title (Cached)" : "Title"),
            value: title
          });
        }

        if (body) {
          discordPayload.embeds[0].fields.push({
            name: (usedCachedBody ? "Body (Cached)" : "Body"),
            value: body
          });
        }

        discordPayload.embeds[0].fields.push({
          name: modlogLinkDesc,
          value: `[Link](${modlogLink})`
        });

        await fetch(settings.webhookURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(discordPayload),
        })
          .then(() => console.log(`Sent Discord message about ${action} by ${moderatorName}`))
          .catch((e) => console.error(`Error sending Discord message about ${action} by ${moderatorName}`, e));
      }
    }
  }
});

// Cache modlist during app install or upgrade
Devvit.addTrigger({
  events: ['AppInstall', 'AppUpgrade'],
  onEvent: async (event, context) => {
    console.log(`Updating cached modlist on ${event.type}`);
    await cacheModerators(context);
  }
});

// Cache text of new and edited posts
Devvit.addTrigger({
  events: ['PostSubmit', 'PostUpdate'],
  onEvent: cachePost
});

// Cache text of new and edited comments
Devvit.addTrigger({
  events: ['CommentSubmit', 'CommentUpdate'],
  onEvent: cacheComment
});

export default Devvit;
