import { Devvit, TriggerContext } from '@devvit/public-api';
import { settings, getValidatedSettings } from './settings.js';

Devvit.configure({
  redditAPI: true,
  http: true,
  redis: true
});

Devvit.addSettings(settings);

Devvit.addTrigger({
  event: 'ModAction',
  onEvent: async (event, context) => {

    const action = event.action;
    if (!action) {
      throw new Error('Missing `action` from ModActionTrigger event');
    }

    const moderator = event.moderator;
    if (!moderator || !moderator.name) {
      throw new Error('Missing `moderator` from ModActionTrigger event');
    }

    const subreddit = event.subreddit;
    if (!subreddit || !subreddit.name) {
      throw new Error('Missing `subreddit` from ModActionTrigger event');
    }

    const settings = await getValidatedSettings(context);

    // Update cached modlist on modlist change
    if (
      action == "acceptmoderatorinvite" || action == "addmoderator" ||
      action == "removemoderator" || action == "reordermoderators"
    ) {
      console.log(`Updating cached modlist on ${action}`);
      await refreshModerators(context);
    }

    // Check if acting moderator is NOT in modlist
    const moderators = await getModerators(context);
    if (!moderators.includes(moderator.name) || moderator.name == "shiruken") {

      let link = "";
      let user = "";
      let title = "";
      let body = "";

      // Posts
      const postActions = ["approvelink", "removelink", "spamlink"];
      if (postActions.includes(action)) {
        const post = event.targetPost;
        if (post) {
          if (post.permalink) {
            link = `https://www.reddit.com${post.permalink}`;
          }
          if (post.authorId) {
            user = (await context.reddit.getUserById(post.authorId)).username;
          }
          if (post.title) {
            title = post.title;
          }
          if (post.selftext) {
            body = post.selftext;
          }
        }
      }

      // Comments
      const commentActions = ["approvecomment", "removecomment", "spamcomment"];
      if (commentActions.includes(action)) {
        const comment = event.targetComment;
        if (comment) {
          if (comment.permalink) {
            link = `https://www.reddit.com${comment.permalink}`;
          }
          if (comment.author) {
            user = (await context.reddit.getUserById(comment.author)).username;
          }
          if (comment.body) {
            body = comment.body;
          }
        }
      }

      let isUser = false;
      let modlogLinkDesc = "View Admin Modlog";
      let modlogLink = `https://www.reddit.com/r/${subreddit.name}/about/log?mod=a&moderatorNames=a`;
      if (moderator.name != "Anti-Evil Operations" && moderator.name != "Reddit Legal") {
        isUser = true;
        modlogLinkDesc = "View User Modlog";
        modlogLink = `https://www.reddit.com/r/${subreddit.name}/about/log?mod=${moderator.name}&moderatorNames=${moderator.name}`;
      }

      // Send Modmail
      if (settings.sendModmail) {
        const msg = `**${ isUser ? "u/" : "" }${moderator.name}** has performed an action in r/${subreddit.name}:\n\n` +
                    `* **Action:** \`${action}\`` +
                    (link ? `\n\n* **Permalink:** ${link}` : "") +
                    (user ? `\n\n* **Target User:** u/${user}` : "") +
                    (title ? `\n\n* **Title:** ${title}` : "") +
                    (body ? `\n\n* **Body:** ${body}` : "") +
                    `\n\n[**${modlogLinkDesc}**](${modlogLink})\n\n` +
                    `^(Notification generated by )[^Admin ^Tattler](https://developers.reddit.com/apps/admin-tattler)` +
                    `^(. Configure settings )[^here](https://developers.reddit.com/r/${subreddit.name}/apps/admin-tattler)^(.)`;
        await context.reddit.modMail.createConversation({
          to: "admin-tattler",
          subject: "Admin Action Detected",
          body: msg,
          subredditName: subreddit.name,
        })
        .then(() => console.log(`Sent modmail about ${action} by ${moderator.name}`))
        .catch((e) => console.error(`Error sending modmail about ${action} by ${moderator.name}`, e));
      }

      // Send to Slack
      if (settings.webhookURL && settings.webhookURL.startsWith("https://hooks.slack.com/")) {
        const slackPayload = {
          blocks: [
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `*${ isUser ? "u/" : "" }${moderator.name}* has performed an action in r/${subreddit.name}:`
              }
            },
            {
              type: "context",
              elements: [
                {
                  type: "mrkdwn",
                  text: `*Action:* \`${action}\`` +
                        (link ? `\n*Permalink:* ${link}` : "") +
                        (user ? `\n*Target User:* <https://www.reddit.com/user/${user}|u/${user}>` : "") +
                        (title ? `\n*Title:* ${title}` : "") +
                        (body ? `\n*Body:* ${body}` : "")
                }
              ]
            },
            {
              type: "actions",
              elements: [
                {
                  type: "button",
                  text: {
                    type: "plain_text",
                    text: modlogLinkDesc
                  },
                  url: modlogLink
                }
              ]
            },
            {
              type: "section",
              text: {
                type: "mrkdwn",
                text: `\`\`\`${JSON.stringify(event)}\`\`\``
              }
            }
          ]
        };
        await fetch(settings.webhookURL, {
          method: 'POST',
          body: JSON.stringify(slackPayload),
        })
          .then(() => console.log(`Sent Slack message about ${action} by ${moderator.name}`))
          .catch((e) => console.error(`Error sending Slack message about ${action} by ${moderator.name}`, e));
      }

      // Send to Discord
      if (settings.webhookURL && settings.webhookURL.startsWith("https://discord.com/api/webhooks/")) {
        const discordPayload = {
          username: "Admin Tattler",
          content: `**${ isUser ? "u/" : "" }${moderator.name}** has performed an action in r/${subreddit.name}`,
          embeds: [
            {
              color: 16711680, // #FF0000
              fields: [
                {
                  name: "Action",
                  value: `\`${action}\``
                }
              ]
            }
          ]
        };

        if (link) {
          discordPayload.embeds[0].fields.push({
            name: "Permalink",
            value: link
          });
        }

        if (user) {
          discordPayload.embeds[0].fields.push({
            name: "Target User",
            value: `[u/${user}](https://www.reddit.com/user/${user})`
          });
        }

        if (title) {
          discordPayload.embeds[0].fields.push({
            name: "Title",
            value: title
          });
        }

        if (body) {
          discordPayload.embeds[0].fields.push({
            name: "Body",
            value: body
          });
        }

        discordPayload.embeds[0].fields.push({
          name: modlogLinkDesc,
          value: `[Link](${modlogLink})`
        });

        await fetch(settings.webhookURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(discordPayload),
        })
          .then(() => console.log(`Sent Discord message about ${action} by ${moderator.name}`))
          .catch((e) => console.error(`Error sending Discord message about ${action} by ${moderator.name}`, e));
      }
    }
  }
});

// Cache modlist during app install or upgrade
Devvit.addTrigger({
  events: ['AppInstall', 'AppUpgrade'],
  onEvent: async (event, context) => {
    console.log(`Updating cached modlist on ${event.type}`);
    await refreshModerators(context);
  }
});

/**
 * Refresh cached subreddit modlist
 * Write string representation of array to Redis
 * @param context A TriggerContext object
 */
async function refreshModerators(context: TriggerContext) {
  const subreddit = await context.reddit.getCurrentSubreddit();
  const moderators: string[] = [];
  try {
    for await(const moderator of subreddit.getModerators({ pageSize: 500 })) {
      moderators.push(moderator.username);
    }
  } catch (err) {
    throw new Error(`Error fetching modlist for r/${subreddit.name}: ${err}`);
  }

  if (!moderators.length) {
    throw new Error(`Fetched modlist for r/${subreddit.name} is empty, skipping cache update`);
  }

  await context.redis
    .set("mods", moderators.toString())
    .then(() => console.log(`Wrote ${moderators.length} moderators to Redis`))
    .catch((e) => console.error('Error writing moderators to Redis', e));
}

/**
 * Get array of cached moderator usernames from Redis
 * @param context A TriggerContext object
 * @returns A promise that resolves to an array of moderator usernames
 */
async function getModerators(context: TriggerContext): Promise<string[]> {
  const moderators = await context.redis.get("mods");
  if (!moderators) {
    throw new Error('Cached modlist is empty');
  }
  return moderators.split(",");
}

export default Devvit;
